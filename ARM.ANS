Test date: 04/07/23  18:15:59 
The number of times you used the grading program is 3 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
ARM Grading System Version 4.2
Student: St#1=Qizheng              St#2t=Caroline             Type=Team                
Grading program history
   *** Grading Run.  Date: 04/05/23  21:00:56 
   *** Grading Run.  Date: 04/07/23  12:57:28 
   *** Grading Run.  Date: 04/07/23  18:15:59 
Comparing your program's key.out to the expected output
Test ran correctly.
++ Grade ++  100 = Points earned for correct answers.

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     3  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC766&}xC6&k~C6&juiC6&zuzC766&Zkyz&jgzk@&6:56=589&&7>@7;@;?&

Building the file arm.ans for electronic submission...
;---------------------------------------------------------------------
; File:     armkey.s
;
; Function: This program copies an ASCII file
;           It assumes the file uses CR/LF as the end of line sequence
;           - It opens an input file named key.in
;           - It opens an output file named key.out
;           - It reads one line of text from the input file.
;	    - It prints out all characters A-Z and a-z (converting a-z to uppercase)
;	    - It ignores all other characters
;           - It writes characters on that one line to the output file then a CR LF
;           - It loops until it reaches end of file
;           - It closes the input and output file
;
; Author:   Caroline Wendelburg
;	    Qizheng Jin
;
; Changes:  Date        Reason
;           ----------------------------------------------------------
;           05/07/2023  Original version
;
;---------------------------------------------------------------------


;----------------------------------
; Software Interrupt values
;----------------------------------
         .equ SWI_Open,  0x66     ;Open  a file
         .equ SWI_Close, 0x68     ;Close a file
         .equ SWI_PrStr, 0x69     ;Write a null-ending string
         .equ SWI_RdStr, 0x6a     ;Read a string and terminate with null char
         .equ SWI_Exit,  0x11     ;Stop execution
;----------------------------------

         .global   _start
         .text

_start:
;----------------------------------
; open input file
; - r0 points to the file name
; - r1 0 for input
; - the open swi is 66h
; - after the open r0 will have the file handle
;----------------------------------
         ldr  r0, =InFileName     ;r0 points to the file name
         ldr  r1, =0              ;r1 = 0 specifies the file is input
         swi  SWI_Open            ;open the file ... r0 will be the file handle
         ldr  r1, =InFileHandle   ;r1 points to handle location
         str  r0, [r1]            ;store the file handle
;----------------------------------


;----------------------------------
; open output file
; - r0 points to the file name
; - r1 1 for output
; - the open swi is 66h
; - after the open r0 will have the file handle
;----------------------------------
         ldr  r0, =OutFileName    ;r0 points to the file name
         ldr  r1, =1              ;r1 = 1 specifies the file is output
         swi  SWI_Open            ;open the file ... r0 will be the file handle
         ldr  r1, =OutFileHandle  ;r1 points to handle location
         str  r0, [r1]            ;store the file handle
;----------------------------------


;----------------------------------
; read a string from the input file
; - r0 contains the file handle
; - r1 points to the input string buffer
; - r2 contains the max number of characters to read
; - the read swi is 6ah
; - the input string will be terminated with 0
;----------------------------------
_read:                            ;
         ldr  r0, =InFileHandle   ;r0 points to the input file handle
         ldr  r0, [r0]            ;r0 has the input file handle
         ldr  r1, =String         ;r1 points to the input string
         ldr  r2, =80             ;r2 has the max size of the input string
         swi  SWI_RdStr           ;read a string from the input file
         cmp  r0,#0               ;no characters read means EOF
         beq  _exit               ;so close and exit
	 ldr r4, =Output
;----------------------------------

;----------------------------------
; get the next letter from the input string
;----------------------------------
nextLetter:
	 ldrb r3, [r1], #1   ; load next character into r3

;----------------------------------
; checks the next letter in the input string
; and jumps to print if valid letter	
;----------------------------------
checkLetter:   
         cmp r3, #0x00	     ; if 0x00, print line and read next
         beq storeChar	     ; store and print this char

	 cmp r3, #0x20	     ; if letter is a space
         beq storeChar       ; store and print a space

         cmp r3, #'A'        ; compare letter  with 'A'
         blt nextLetter      ; if less than 'A', check next letter
         cmp r3, #'Z'        ; compare letteriwith 'Z'
         ble storeChar 	     ; If less than or equal to 'Z', store and print letter
    
         sub r3, r3, #0x20   ; if not uppercase, convert lowercase letter to uppercase
         bal checkLetter     ; test letter again


;----------------------------------
; stores character in output string
;----------------------------------
storeChar:
	strb r3, [r4]		  ; store char just read into output string
	add  r4, r4, #1		  ; move ahead one in output string
	cmp  r3, #0x00	          ; was letter 0x00?
	bne  nextLetter		  ; if not, next letter

;----------------------------------
; Write the outputs string
;----------------------------------
_write:                           
         ldr  r0, =OutFileHandle  ; r0 points to the output file handle
         ldr  r0, [r0]            ; r0 has the output file handle
         ldr  r1, =Output         ;r1 points to the output string
         swi  SWI_PrStr           ;write the null terminated string
                                  ;
         ldrb r1, [r1]            ;get the first byte of the line
         cmp  r1, #0x1A           ;if line  was DOS eof then do not write CRLF
         beq  _read               ;so do next read
                                  ;
         ldr  r1, =CRLF           ;r1 points to the CRLF string
         swi  SWI_PrStr           ;write the null terminated string
                                  ;
         bal  _read               ;read the next line
;----------------------------------


;----------------------------------
; Close input and output files
; Terminate the program
;----------------------------------
_exit:                            ;
         ldr  r0, =InFileHandle   ;r0 points to the input  file handle
         ldr  r0, [r0]            ;r0 has the input file handle
         swi  SWI_Close           ;close the file
                                  ;
         ldr  r0, =OutFileHandle  ;r0 points to the output file handle
         ldr  r0, [r0]            ;r0 has the output file handle
         swi  SWI_Close           ;close the file
                                  ;
         swi  SWI_Exit            ;terminate the program
;----------------------------------


         .data
;----------------------------------
InFileHandle:  .skip 4            ;4 byte field to hold the input  file handle
OutFileHandle: .skip 4            ;4 byte field to hold the output file handle
                                  ;
InFileName:    .asciz "KEY.IN"   ;Input  file name, null terminated
                                  ;
String:        .skip 80          ;reserve a 128 byte string
Output:	       .skip 80		 ; reserve 80 bytes for length
                                  ;
CRLF:          .byte 13, 10, 0    ;CR LF
                                  ;
OutFileName:   .asciz "KEY.OUT"  ;Output file name, null terminated
;----------------------------------


         .end
